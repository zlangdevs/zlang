struct Person {
    name arr<u8, 15> = "unnamed",
    age i32 = 0,
    is_male bool = false,
    id u64 = 1
}

struct Point {
    x i32,
    y i32
}

struct Rectangle {
    width i32,
    height i32
}


struct Line {
    start Point,
    end Point
}

fun print_info(p: Person) >> void {
    @printf("====Info====\nName: %s\nAge: %d\nMale: ", p.name, p.age);
    if p.is_male {@printf("yes\n");} else {@printf("no\n");}
    @printf("ID: %d\n", p.id);
}

fun print_point(self: Point) >> void {
    @printf("Point(%d, %d)\n", self.x, self.y);
}

fun translate(self: Point, dx: i32, dy: i32) >> Point {
    Point result;
    result.x = self.x + dx;
    result.y = self.y + dy;
    return result;
}

fun distance_from_origin(self: Point) >> f64 {
    i32 x_squared = self.x * self.x;
    i32 y_squared = self.y * self.y;
    ?? we do not have sqrt function :(
    return (x_squared + y_squared) as _;
}

fun set_coords(self: Point, new_x: i32, new_y: i32) >> Point {
    Point updated;
    updated.x = new_x;
    updated.y = new_y;
    return updated;
}

fun print_rect(self: Rectangle) >> void {
    @printf("Rectangle(%dx%d)\n", self.width, self.height);
}

fun area(self: Rectangle) >> i32 {
    return self.width * self.height;
}

fun scale(self: Rectangle, factor: i32) >> Rectangle {
    Rectangle scaled;
    scaled.width = self.width * factor;
    scaled.height = self.height * factor;
    return scaled;
}

fun gen_line(x1: i32, y1: i32, x2: i32, y2: i32) >> Line {
    Point lstart;
    lstart.x = x1;
    lstart.y = y1;
    Point lend;
    lend.x = x2;
    lend.y = y2;
    Line res;
    res.start = lstart;
    res.end = lend;
    return res;
} 

fun add(a: i32, b: i32) >> i32 {return a + b;}
fun mul(a: i32, b: i32) >> i32 {return a * b;}
fun idp(p: ptr<i32>) >> ptr<i32> {return p;}

struct MathOps {
    bin ptr<i32(i32, i32)>,
    other ptr<i32(i32, i32)>,
    transform ptr<ptr<i32>(ptr<i32>)>
}

fun apply_bin(m: MathOps, x: i32, y: i32) >> i32 {
    ptr<i32(i32, i32)> f = m.bin;
    return f(x, y);
}

fun swap_and_apply(m: MathOps, x: i32, y: i32) >> i32 {
    ptr<i32(i32, i32)> f = m.other;
    return f(x, y);
}

fun ptr_roundtrip(m: MathOps, p: ptr<i32>) >> ptr<i32> {
    ptr<ptr<i32>(ptr<i32>)> t = m.transform;
    return t(p);
}

fun main() >> i32 {
    Person alex;
    Person default; ?? normies lol
    Point origin;

    alex.name = "Alex Johnson";
    alex.age = 25;
    alex.id = 12345;
    alex.is_male = true;
    
    Person bob = Person{
        name = "Bob Smith",
        age = 30,
        is_male = true
    };
    
    origin.x = 10;
    origin.y = 20;

    @printf("Name: %s\n", alex.name);
    @printf("Age: (expected 25):%d\n", alex.age);

    i32 current_age = alex.age;
    i32 point_x = origin.x;
    @printf("(expected 35):%d\n", current_age + point_x);
    @printf("(expected 30):%d\n", bob.age);
    @printf("(expected 1):%d\n", default.id);
    ?? @printf("(expected 66): %d\n". bob.name[0]); causes strange error (compiler segfault)
    
    print_info(default);
    print_info(alex);
    bob.print_info();
    Line tline = gen_line(0, 1, 2, 3);
    @printf("Line start: %d, %d\n", tline.start.x, tline.start.y);
    tline.start.x = 10;
    @printf("After assignment: %d, %d\n", tline.start.x, tline.start.y);
    arr<Line, 5> lines;
    i32 sum = 0;
    for i8 i = 0; i < 5; i++ {
        lines[i] = gen_line(i, i, i, i);
    }
    for i8 i = 0; i < 5; i++ {
        sum += lines[i].start.x;
    }
    @printf("(expected 10):%d\n", sum);
    
    Point p1;
    p1.x = 3;
    p1.y = 4;

    @printf("Original point: ");
    p1.print_point();

    ?? Test method with return value
    f64 dist = p1.distance_from_origin();
    @printf("Distance from origin: expected(25.0):%.1f\n", dist);

    ?? Test method with parameters returning new struct
    Point p2 = p1.translate(10, 20);
    @printf("Translated point: ");
    p2.print_point();

    ?? Test method that modifies coordinates
    Point p3 = p1.set_coords(100, 200);
    @printf("Updated point: ");
    p3.print_point();

    ?? Test Rectangle methods
    Rectangle rect;
    rect.width = 5;
    rect.height = 8;

    @printf("Original rectangle: ");
    rect.print_rect();

    i32 rect_area = rect.area();
    @printf("Area: (expected 40):%d\n", rect_area);

    Rectangle big_rect = rect.scale(3);
    @printf("Scaled rectangle: ");
    big_rect.print_rect();

    i32 big_area = big_rect.area();
    @printf("Scaled area: (expected 360):%d\n", big_area);
    
    MathOps ops;
    ops.bin = add;
    ops.other = mul;
    ops.transform = idp;

    i32 x = 6;
    i32 y = 7;
    i32 r1 = ops.apply_bin(x, y);
    @printf("(expected 13):%d\n", r1);

    i32 r2 = ops.swap_and_apply(x, y);
    @printf("(expected 42):%d\n", r2);

    ptr<i32> px = &x;
    ptr<i32> pr = ops.ptr_roundtrip(px);
    @printf("ptr roundtrip: %p -> %p\n", px, pr);
    return 0;
}