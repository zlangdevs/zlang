enum Color {
    RED,
    GREEN = 10,
    BLUE
}

enum Status {
    PENDING,
    RUNNING = 100,
    COMPLETED,
    FAILED = 200
}

fun main() >> i32 {
    @printf("=== Testing Enum Values ===\n");
    
    ?? Test 1: Qualified access (EnumName.value)
    @printf("(expected 0):%d\n", Color.RED);
    @printf("(expected 10):%d\n", Color.GREEN);
    @printf("(expected 11):%d\n", Color.BLUE);

    ?? Test 2: C-style direct access (just value name)
    @printf("(expected 0):%d\n", RED);
    @printf("(expected 10):%d\n", GREEN);
    @printf("(expected 11):%d\n", BLUE);

    ?? Test 3: Another enum with qualified access
    @printf("(expected 0):%d\n", Status.PENDING);
    @printf("(expected 100):%d\n", Status.RUNNING);
    @printf("(expected 101):%d\n", Status.COMPLETED);
    @printf("(expected 200):%d\n", Status.FAILED);

    ?? Test 4: C-style access for second enum
    @printf("(expected 0):%d\n", PENDING);
    @printf("(expected 100):%d\n", RUNNING);
    @printf("(expected 101):%d\n", COMPLETED);
    @printf("(expected 200):%d\n", FAILED);

    ?? Test 5: Use enum values in expressions
    i32 color_sum = RED + GREEN + BLUE;
    @printf("(expected 21):%d\n", color_sum);

    ?? Test 6: Use in comparisons
    i32 current_status = RUNNING;
    if (current_status == RUNNING) {
        @printf("Status is RUNNING\n");
    }

    ?? Test 7: Use in variable initialization
    i32 my_color = BLUE;
    @printf("(expected 11):%d\n", my_color);

    ?? Test 8: Const variable with enum value
    const i32 DEFAULT_COLOR = GREEN;
    @printf("(expected 10):%d\n", DEFAULT_COLOR);
    
    @printf("\n=== All enum tests passed! ===\n");
    return 0;
}

fun @printf(format: ptr<u8>) >> i32;
